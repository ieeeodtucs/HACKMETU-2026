/**
 * CVE API Routes
 *
 * - GET /api/cves/search?q=openssl        → urun adina gore CVE ara
 * - GET /api/cves/stats                   → genel istatistikler
 * - GET /api/cves/:id                     → tek CVE detayi
 * - POST /api/cves/scan                   → dpkg -l ciktisini parse edip CVE match
 */

import { Hono } from "hono";
import { pool } from "./db.js";

const cveRoutes = new Hono();

// ===== GET /api/cves/stats =====
cveRoutes.get("/stats", async (c) => {
  const [total, affected, severity] = await Promise.all([
    pool.query("SELECT count(*) FROM cves"),
    pool.query("SELECT count(*) FROM cve_affected"),
    pool.query(
      "SELECT severity, count(*)::int as count FROM cves WHERE severity IS NOT NULL GROUP BY severity ORDER BY count DESC"
    ),
  ]);

  return c.json({
    success: true,
    stats: {
      totalCves: Number(total.rows[0].count),
      totalAffected: Number(affected.rows[0].count),
      bySeverity: severity.rows,
    },
  });
});

// ===== GET /api/cves/search?q=openssl&limit=20 =====
cveRoutes.get("/search", async (c) => {
  const q = c.req.query("q")?.trim();
  const limit = Math.min(Number(c.req.query("limit")) || 50, 200);

  if (!q) {
    return c.json({ success: false, error: "q parametresi gerekli" }, 400);
  }

  // Exact substring match on product/vendor + trigram on description
  const result = await pool.query(
    `SELECT DISTINCT ON (c.cve_id)
       c.cve_id, c.title, c.description, c.severity, c.cvss_score,
       c.cwe_id, c.date_published,
       a.vendor, a.product, a.version_lt, a.version_lte, a.version_value
     FROM cve_affected a
     JOIN cves c ON c.cve_id = a.cve_id
     WHERE
       lower(a.product) = lower($1)
       OR lower(a.vendor) = lower($1)
       OR lower(a.product) LIKE '%' || lower($1) || '%'
     ORDER BY c.cve_id, c.cvss_score DESC NULLS LAST
     LIMIT $2`,
    [q, limit]
  );

  return c.json({
    success: true,
    query: q,
    count: result.rows.length,
    results: result.rows,
  });
});

// ===== GET /api/cves/:id =====
cveRoutes.get("/:id", async (c) => {
  const id = c.req.param("id").toUpperCase();

  const [cve, affected] = await Promise.all([
    pool.query("SELECT * FROM cves WHERE cve_id = $1", [id]),
    pool.query(
      "SELECT vendor, product, version_value, version_lt, version_lte, version_start, version_type, default_status FROM cve_affected WHERE cve_id = $1",
      [id]
    ),
  ]);

  if (cve.rows.length === 0) {
    return c.json({ success: false, error: "CVE bulunamadi" }, 404);
  }

  return c.json({
    success: true,
    cve: { ...cve.rows[0], affected: affected.rows },
  });
});

// ===== POST /api/cves/scan =====
// Body: { packages: "dpkg -l ciktisi" } veya { packages: [{name, version}] }
cveRoutes.post("/scan", async (c) => {
  const body = await c.req.json<{
    packages: string | Array<{ name: string; version: string }>;
    agent_id?: string;
  }>();

  if (!body.packages) {
    return c.json({ success: false, error: "packages gerekli" }, 400);
  }

  // Parse packages
  let pkgList: Array<{ name: string; version: string }>;

  if (typeof body.packages === "string") {
    pkgList = parseDpkgOutput(body.packages);
  } else {
    pkgList = body.packages;
  }

  if (pkgList.length === 0) {
    return c.json({
      success: true,
      vulnerabilities: [],
      scanned: 0,
      message: "Paket listesi bos",
    });
  }

  // Her paket icin arama yapilacak variant isimler olustur
  // { searchTerm -> originalPkgName } mapping
  const searchMap = new Map<string, string>();

  for (const pkg of pkgList) {
    const name = pkg.name.toLowerCase();
    searchMap.set(name, pkg.name);

    // lib prefix kaldir: libssl3 -> ssl3, libcurl4 -> curl4
    if (name.startsWith("lib")) {
      const stripped = name.slice(3);
      searchMap.set(stripped, pkg.name);
      // Sondaki rakami da kaldir: ssl3 -> ssl, curl4 -> curl
      const noDigit = stripped.replace(/[0-9.]+$/, "");
      if (noDigit.length >= 2) searchMap.set(noDigit, pkg.name);
    }

    // -dev, -common, -bin suffix kaldir
    const base = name.replace(/-(dev|common|bin|utils|data|doc|dbg|lib|core)$/, "");
    if (base !== name && base.length >= 2) searchMap.set(base, pkg.name);

    // Sondaki version numarasini kaldir: python3.11 -> python
    const noVer = name.replace(/[0-9.]+$/, "");
    if (noVer !== name && noVer.length >= 2) searchMap.set(noVer, pkg.name);
  }

  const searchTerms = [...searchMap.keys()].filter((t) => t.length >= 2);

  if (searchTerms.length === 0) {
    return c.json({ success: true, vulnerabilities: [], scanned: pkgList.length });
  }

  // Batch query: exact product name match (case-insensitive)
  // Her terimi OR ile bagla ama sadece exact veya contains match yap (trigram degil — cok fazla false positive)
  const conditions = searchTerms
    .map((_, i) => `lower(a.product) = $${i + 1} OR lower(a.product) LIKE '%' || $${i + 1} || '%'`)
    .join(" OR ");

  const result = await pool.query(
    `SELECT DISTINCT ON (c.cve_id)
       c.cve_id, c.title, c.description, c.severity, c.cvss_score,
       c.date_published, c.cwe_id,
       a.vendor, a.product, a.version_lt, a.version_lte, a.version_value,
       a.version_start
     FROM cve_affected a
     JOIN cves c ON c.cve_id = a.cve_id
     WHERE ${conditions}
     ORDER BY c.cve_id, c.cvss_score DESC NULLS LAST
     LIMIT 500`,
    searchTerms
  );

  // Map results to packages
  const vulnerabilities = result.rows.map((row) => {
    const product = row.product.toLowerCase();
    let matchedPkg: { name: string; version: string } | undefined;

    // En iyi match'i bul
    for (const [term, origName] of searchMap) {
      if (product === term || product.includes(term) || term.includes(product)) {
        matchedPkg = pkgList.find((p) => p.name === origName);
        if (matchedPkg) break;
      }
    }

    return {
      cve_id: row.cve_id,
      severity: row.severity,
      cvss_score: row.cvss_score,
      title: row.title,
      description: row.description?.slice(0, 300),
      affected_product: row.product,
      affected_vendor: row.vendor,
      version_lt: row.version_lt,
      version_lte: row.version_lte,
      matched_package: matchedPkg?.name || null,
      matched_version: matchedPkg?.version || null,
      date_published: row.date_published,
    };
  });

  // Severity'ye gore sirala
  const severityOrder: Record<string, number> = {
    CRITICAL: 4, HIGH: 3, MEDIUM: 2, LOW: 1, NONE: 0,
  };
  vulnerabilities.sort(
    (a, b) =>
      (severityOrder[b.severity] ?? -1) - (severityOrder[a.severity] ?? -1)
  );

  return c.json({
    success: true,
    scanned: pkgList.length,
    vulnerabilities,
    summary: {
      total: vulnerabilities.length,
      critical: vulnerabilities.filter((v) => v.severity === "CRITICAL").length,
      high: vulnerabilities.filter((v) => v.severity === "HIGH").length,
      medium: vulnerabilities.filter((v) => v.severity === "MEDIUM").length,
      low: vulnerabilities.filter((v) => v.severity === "LOW").length,
    },
  });
});

// ===== dpkg -l ciktisini parse et =====
function parseDpkgOutput(raw: string): Array<{ name: string; version: string }> {
  const packages: Array<{ name: string; version: string }> = [];
  const lines = raw.split("\n");

  for (const line of lines) {
    // dpkg -l format: ii  package-name  version  arch  description
    const match = line.match(/^ii\s+(\S+)\s+(\S+)/);
    if (match) {
      packages.push({
        name: match[1].split(":")[0], // arch suffix kaldir (package:amd64 -> package)
        version: match[2],
      });
    }
  }

  return packages;
}

export { cveRoutes };
